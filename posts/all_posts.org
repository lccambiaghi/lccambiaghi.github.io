#+TITLE: all posts
#+DRAFT: t
#+OPTIONS: num:nil toc:nil \n:nil author:nil date:nil title:nil

* About Me
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/about.md
:END:

** Who am I
My name is Luca, I am a Computer Scientist.
I grew up in northern Italy, orbiting around Milan.
In 2016 I moved to Copenhagen to achieve my MSc in Computer Science.

My favourite hobby is travelling.
After my graduation I spent 3 months backpacking across Chile, Bolivia, Peru and Colombia.
Another beautiful backpacking trip I have done was when visiting Nepal and India.

I also love reading and watching good movies and TV show.
The last book I read was "12 rules for life" by Jordan Peterson.
The last TV show I (re)watched was Breaking Bad.

You can contact me by email at
#+HTML: <span style="cursor: pointer" onclick="this.textContent = ('luca.cambiaghi' + '@me' + String.fromCharCode(46) + 'com'); this.onclick = null; this.style.cursor='default'">(click.here.or.see.resume)</span>

** What I do
I am currently working as Data Scientist in the Demand Forecasting team.
My team is responsible for providing users with hundreds of thousand of time series forecast every day.

I have experience in developing real world, scalable machine learning pipelines.
I am skilled in big data ingestion and cleaning, feature engineering, model development, deployment and monitoring.

Here you can see my full [[https://luca.cambiaghi.me/resume][Resume]].

** How I do it
I am most productive with Python.
On a day to day basis I work with ~numpy~, ~pandas~ and ~scikit-learn~.

During my first year as a FTE I added Docker and Kubernetes to my toolbox.

I am fascinated by ~clojure~ and functional programming.
My free time projects are often an attempt to learn some part of the ecosystem.
I look forward to the day I will be doing my data science work in ~clojure~.

* New website!
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/new-website.md
:END:
title: New website!
subtitle: Why and how I set up my personal website
date: 2020-05-28
id: new-website
tags: clojurescript shadow-cljs org

** The problem
I have always wanted a personal website. I have attempted several times at creating one.
The first function a personal website should serve is showcase your achievements, e.g. your former experience and projects.
The second function I have always seeked from my website is technical blogging.
Moreover, I wanted my website to be hosted for free, without any limitations.

In regards to blogging, I wanted to do it in the simplest way. Not too simple though, as Einstein said:
#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE
In my previous attempts at building a website I never reached that sweet spot: things were either too complex or too simple.
In this blog post I explain what brought me to this point.

** Previous approaches
A popular approach is to host a static website on Github Pages with Ruby+Jekyll.
Github recently made this very easy with the [[https://github.com/github/personal-website][personal website project]].
I tried twice that approach because of how easy and fast it is to set up.

The first time I set up a simple website was few years ago and I did it with a minimal Jekyll template to showcase my github projects and my skills.
I had a page where I could easily write blog posts in ~.md~ files, placing the posts in a certain folder structure with a certain filename.
Simple enough, right? Maybe too simple. I could not easily control the website template. I had to write my posts in ~markdown~ files.
I quickly lost interest in the website and never blogged once.

The second time around was at the beginning of 2020, shortly after discovering Emacs.
I saw a beautiful blog online and made it a day's quest to replicate it on my ~gh-pages~ branch.
What the author was using was an R library called ~rmarkdown~, which under the hood uses ~knitr~ + ~pandoc~ to render ~.Rmd~ files.
The final touch I added was so I could write posts using my favourite markup language, i.e. Org Mode.
I could write ~.org~ files, export them to ~.Rmd~ files and finally render them with ~rmarkdown~.
The website's style was stunning also! Very easy to steal some CSS from his website.

I could blog writing ~.org~ files and I had a beautiful website.. Still I never blogged once. Maybe it was not simple enough.
The setup must have been working very well for its original author, a Data Scientist writing a lot of ~.Rmd~ analyses. Not so much for me.

** This approach
Lately I have been very fascinated by the Clojure programming language. I will write a post in the future about it.
In the websites I am lurking, the community often speaks about Clojurescript which can compile to Javascript code.
Some of the ~cljs~ frameworks for simple-page applications seem simple and elegant (like most things Clojure related).

Today I found a minimal, beautiful blog set up with ~shadow-cljs~, which had very little code, all of which was understandable enough.
It looks like the author is a ~js~ and ~cljs~ developer, so it has been interesting to learn some best practices since I have absolutely zero knowledge of frontend development.

Well, I forked his repo and it was extremely quick to build the website locally and deploy it to netlify!
New concepts I need to understand more:
- ~yarn~ > ~npm~ for managing dependencies, building and releasing
- ~tailwind~ + ~postcss~ for easy customization of your website's style
- ~yarn shadow-cljs watch app~ to develop while hot-reloading the website a-la-figwheel
- Connecting to the ~clojurescript~ REPL to interact with the browser

This is a very exciting environment to develop my website and customize it to my liking! No more deciphering templates and stealing off CSS, I will customize it how I want.

The second news, even more exciting, is that the author wrote a simple logic to parse ~.md~ and populate the website.
This means that to write my blog posts I can write with Org Mode and easily export to ~.md~.
I will also adopt the approach used in ~ox-hugo~, that is to have a single ~.org~ file and have posts live under a heading.
I can then export a single post with =,e C-s mm=, i.e. calling ~org-export-dispatch~, narrowing the scope to the subtree and exporting to a markdown file.

I really like having the full control over the website. Deploying to netlify means that I am not limited to what Github Pages lets me do.
In the future I would like to explore different things, like embedding an interactive ~D3~ visualization or a ~vega-lite~ SVG.
I am happy to *need* to understand the details for these integrations instead of resorting to a magical plugin in an obscure template (like with ~hugo~).

** Why blogging?
Technical blogging is a great opportunity to learn how to explain something you _think_ you know something about and how to organise your thoughts.
Before writing this post I thought I had a clear idea of what to write but at the end of the post I can see that I digressed and I could have benefitted from organizing the structure of the post beforehand.
It's okay since it is my first post, but see? Already learning!

In the future I plan to write about the things I deem interesting that I am exploring.
I do this for self documentation and to maybe help a fellow user who might come across the same problem I was solving and maybe it will help him save some time.
I will adjust with time around a certain size and type of content. I expect the two main categories will be data science and software engineering tooling.
* Vega-lite in Clojure
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/vega-lite-clj.md
:END:
title: Vega-lite in Clojure
subtitle: How to write visualizations as code
date: 2020-06-02
id: vega-lite-clj
tags: vega-lite clojure

** Discovering Vega-lite
I am in the middle of my journey discovering Clojure and its ecosystem of libraries.
So far I have explored quite thoroughly the areas of Data Science (most notable mention: ~tech.ml.dataset~) and R/Python interoperability (mentions: ~libpython-clj~ and ~clojisr~).
The incredible developers behind these libraries often discuss about data visualization and they seem fond of one "framework" in particular, and that is Vega-Lite.

Of course, there is a particularly popular Clojure library for manipulating visualizations and that is ~Oz~.
Out of curiousity, I have watched the canonical [[https://www.youtube.com/watch?v=9uaHRWj04D4][introductory video]] to Vega-Lite and I was really amazed by its simplicity and power of expression.
In brief:
- Vega is designed by following guidelines outlined in the Grammar of Graphics
- Vega is built "on top" of ~d3.js~
- Vega-lite is a "lighter" version of Vega, less verbose and with "sane defaults"

After reading about it and experimenting with it, I understand why the smart people of the Clojure community are fascinated by this library.
Consider this plot:
#+BEGIN_EXPORT html
<div> <svg class="marks" width="350" height="247" viewBox="0 0 350 247" style="background-color: white;"><defs><style>.vega-svg-root * { fill: none; } .vega-svg-root tspan { fill: inherit; } .vega-svg-root path { stroke-miterlimit: 10; }</style></defs><g class="vega-svg-root" transform="translate(44,10)"><g class="mark-group role-frame root" role="graphics-object" aria-roledescription="group mark container"><g transform="translate(0,0)"><path class="background" aria-hidden="true" d="M0.5,0.5h300v200h-300Z" style="fill: transparent; stroke: rgb(221, 221, 221);"></path><g><g class="mark-group role-axis" aria-hidden="true"><g transform="translate(0.5,0.5)"><path class="background" aria-hidden="true" d="M0,0h0v0h0Z" style="pointer-events: none;"></path><g><g class="mark-rule role-axis-grid" style="pointer-events: none;"><line transform="translate(0,200)" x2="300" y2="0" style="stroke: rgb(221, 221, 221); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,150)" x2="300" y2="0" style="stroke: rgb(221, 221, 221); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,100)" x2="300" y2="0" style="stroke: rgb(221, 221, 221); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,50)" x2="300" y2="0" style="stroke: rgb(221, 221, 221); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,0)" x2="300" y2="0" style="stroke: rgb(221, 221, 221); stroke-width: 1px; opacity: 1;"></line></g></g><path class="foreground" aria-hidden="true" d="" style="pointer-events: none; display: none;"></path></g></g><g class="mark-group role-axis" role="graphics-symbol" aria-roledescription="axis" aria-label="X-axis titled 'Day' for a discrete scale with 15 values: 1, 2, 3, 4, 5, ending with 15"><g transform="translate(0.5,200.5)"><path class="background" aria-hidden="true" d="M0,0h0v0h0Z" style="pointer-events: none;"></path><g><g class="mark-rule role-axis-tick" style="pointer-events: none;"><line transform="translate(10,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(30,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(50,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(70,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(90,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(110,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(130,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(150,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(170,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(190,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(210,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(230,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(250,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(270,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(290,0)" x2="0" y2="5" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line></g><g class="mark-text role-axis-label" style="pointer-events: none;"><text text-anchor="middle" transform="translate(9.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">1</text><text text-anchor="middle" transform="translate(29.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">2</text><text text-anchor="middle" transform="translate(49.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">3</text><text text-anchor="middle" transform="translate(69.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">4</text><text text-anchor="middle" transform="translate(89.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">5</text><text text-anchor="middle" transform="translate(109.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">6</text><text text-anchor="middle" transform="translate(129.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">7</text><text text-anchor="middle" transform="translate(149.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">8</text><text text-anchor="middle" transform="translate(169.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">9</text><text text-anchor="middle" transform="translate(189.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">10</text><text text-anchor="middle" transform="translate(209.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">11</text><text text-anchor="middle" transform="translate(229.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">12</text><text text-anchor="middle" transform="translate(249.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">13</text><text text-anchor="middle" transform="translate(269.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">14</text><text text-anchor="middle" transform="translate(289.5,15)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">15</text></g><g class="mark-rule role-axis-domain" style="pointer-events: none;"><line transform="translate(0,0)" x2="300" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line></g><g class="mark-text role-axis-title" style="pointer-events: none;"><text text-anchor="middle" transform="translate(150,30)" style="font-family: sans-serif; font-size: 11px; font-weight: bold; fill: rgb(0, 0, 0); opacity: 1;">Day</text></g></g><path class="foreground" aria-hidden="true" d="" style="pointer-events: none; display: none;"></path></g></g><g class="mark-group role-axis" role="graphics-symbol" aria-roledescription="axis" aria-label="Y-axis titled 'PM2.5 Value' for a linear scale with values from 0 to 400"><g transform="translate(0.5,0.5)"><path class="background" aria-hidden="true" d="M0,0h0v0h0Z" style="pointer-events: none;"></path><g><g class="mark-rule role-axis-tick" style="pointer-events: none;"><line transform="translate(0,200)" x2="-5" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,150)" x2="-5" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,100)" x2="-5" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,50)" x2="-5" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line><line transform="translate(0,0)" x2="-5" y2="0" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line></g><g class="mark-text role-axis-label" style="pointer-events: none;"><text text-anchor="end" transform="translate(-7,203)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">0</text><text text-anchor="end" transform="translate(-7,153)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">100</text><text text-anchor="end" transform="translate(-7,103)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">200</text><text text-anchor="end" transform="translate(-7,53)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">300</text><text text-anchor="end" transform="translate(-7,3)" style="font-family: sans-serif; font-size: 10px; fill: rgb(0, 0, 0); opacity: 1;">400</text></g><g class="mark-rule role-axis-domain" style="pointer-events: none;"><line transform="translate(0,200)" x2="0" y2="-200" style="stroke: rgb(136, 136, 136); stroke-width: 1px; opacity: 1;"></line></g><g class="mark-text role-axis-title" style="pointer-events: none;"><text text-anchor="middle" transform="translate(-27.701492309570312,100) rotate(-90) translate(0,-2)" style="font-family: sans-serif; font-size: 11px; font-weight: bold; fill: rgb(0, 0, 0); opacity: 1;">PM2.5 Value</text></g></g><path class="foreground" aria-hidden="true" d="" style="pointer-events: none; display: none;"></path></g></g><g class="mark-rect role-mark layer_0_layer_0_marks" role="graphics-object" aria-roledescription="rect mark container"><path aria-label="Day: 1; Value: 54.8" role="graphics-symbol" aria-roledescription="bar" d="M1,172.6h18v27.400000000000006h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 2; Value: 112.1" role="graphics-symbol" aria-roledescription="bar" d="M21,143.95h18v56.05000000000001h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 3; Value: 63.6" role="graphics-symbol" aria-roledescription="bar" d="M41,168.2h18v31.80000000000001h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 4; Value: 37.6" role="graphics-symbol" aria-roledescription="bar" d="M61,181.20000000000002h18v18.799999999999983h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 5; Value: 79.7" role="graphics-symbol" aria-roledescription="bar" d="M81,160.15h18v39.849999999999994h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 6; Value: 137.9" role="graphics-symbol" aria-roledescription="bar" d="M101,131.05h18v68.94999999999999h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 7; Value: 120.1" role="graphics-symbol" aria-roledescription="bar" d="M121,139.95000000000002h18v60.04999999999998h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 8; Value: 103.3" role="graphics-symbol" aria-roledescription="bar" d="M141,148.35h18v51.650000000000006h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 9; Value: 394.8" role="graphics-symbol" aria-roledescription="bar" d="M161,2.6000000000000023h18v197.4h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 10; Value: 199.5" role="graphics-symbol" aria-roledescription="bar" d="M181,100.25h18v99.75h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 11; Value: 72.3" role="graphics-symbol" aria-roledescription="bar" d="M201,163.85h18v36.150000000000006h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 12; Value: 51.1" role="graphics-symbol" aria-roledescription="bar" d="M221,174.45h18v25.55000000000001h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 13; Value: 112" role="graphics-symbol" aria-roledescription="bar" d="M241,144h18v56h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 14; Value: 174.5" role="graphics-symbol" aria-roledescription="bar" d="M261,112.75h18v87.25h-18Z" style="fill: rgb(76, 120, 168);"></path><path aria-label="Day: 15; Value: 130.5" role="graphics-symbol" aria-roledescription="bar" d="M281,134.75h18v65.25h-18Z" style="fill: rgb(76, 120, 168);"></path></g><g class="mark-rect role-mark layer_0_layer_1_marks" role="graphics-object" aria-roledescription="rect mark container"><path aria-label="Day: 9; PM2.5 Value: 300; Value: 394.8" role="graphics-symbol" aria-roledescription="bar" d="M161,2.6000000000000023h18v47.4h-18Z" style="fill: rgb(228, 87, 85);"></path></g><g class="mark-rule role-mark layer_1_layer_0_marks" role="graphics-symbol" aria-roledescription="rule mark container"><line transform="translate(300,50)" x2="-300" y2="0" style="stroke: black;"></line></g><g class="mark-text role-mark layer_1_layer_1_marks" role="graphics-object" aria-roledescription="text mark container"><text text-anchor="end" transform="translate(298,46)" style="font-family: sans-serif; font-size: 11px; fill: black;">hazardous</text></g></g><path class="foreground" aria-hidden="true" d="" style="display: none;"></path></g></g></g></svg> </div>
#+END_EXPORT

This is the plot specification, described in JSON:
#+BEGIN_SRC json
{
  "$schema": "https://vega.github.io/schema/vega-lite/v4.json",
  "description": "The PM2.5 value of Beijing observed 15 days, highlighting the days when PM2.5 level is hazardous to human health. Data source https://chartaccent.github.io/chartaccent.html",
    "layer": [{
      "data": {
        "values": [
          {"Day": 1, "Value": 54.8},
          {"Day": 2, "Value": 112.1},
          {"Day": 3, "Value": 63.6},
          {"Day": 4, "Value": 37.6},
          {"Day": 5, "Value": 79.7},
          {"Day": 6, "Value": 137.9},
          {"Day": 7, "Value": 120.1},
          {"Day": 8, "Value": 103.3},
          {"Day": 9, "Value": 394.8},
          {"Day": 10, "Value": 199.5},
          {"Day": 11, "Value": 72.3},
          {"Day": 12, "Value": 51.1},
          {"Day": 13, "Value": 112.0},
          {"Day": 14, "Value": 174.5},
          {"Day": 15, "Value": 130.5}
        ]
      },
      "layer": [{
        "mark": "bar",
        "encoding": {
          "x": {"field": "Day", "type": "ordinal", "axis": {"labelAngle": 0}},
          "y": {"field": "Value", "type": "quantitative"}
        }
      }, {
        "mark": "bar",
        "transform": [
          {"filter": "datum.Value >= 300"},
          {"calculate": "300", "as": "baseline"}
        ],
        "encoding": {
          "x": {"field": "Day", "type": "ordinal"},
          "y": {"field": "baseline", "type": "quantitative", "title": "PM2.5 Value"},
          "y2": {"field": "Value"},
          "color": {"value": "#e45755"}
        }
      }
    ]}, {
      "data": {
         "values": [{}]
      },
      "encoding": {
        "y": {"datum": 300}
      },
      "layer": [{
        "mark": "rule"
      }, {
        "mark": {
          "type": "text",
          "align": "right",
          "baseline": "bottom",
          "dx": -2,
          "dy": -2,
          "x": "width",
          "text": "hazardous"
        }
      }]
    }
  ]
}
#+END_SRC

It is not the simplest example but I think it speaks great of Vega-Lite expressiveness.
The visualization is divided in two layers and each layer has two sublayers:
- The first layer has simple data associated with it, with the fields "Day" and "Value"
  - The first sublayer has a mark specifying a "bar" plot
  - The field "Day" is encoded to the x axis and "Value" to the y axis
  - The second sublayer is another bar mark with defines transforms:
    - Data below 300 is filtered and 300 is defined as baseline
    - In the encoding there is y, which is the defined baseline
    - There is also y2, which is the values above 300 that we filtered, colored of red
- The second layer has no data but a fixed y encoding to 300
  - The first sublayer has mark "rule", which draws an horizontal line in y
  - The second sublayer has mark "text" and the options describe positioning

I really like this way of composing a visualization.
It is very simple to express the components and quite intuitive how to layer them together.

** Oz
Well, Vega-lite is nothing new, might not be so exciting for the majority of people.
What makes it extremely interesting for me is that it has something in common with Clojure: this visualization spec is just data.
Instead of JSON, it can be represented in YAML or EDN. In fact, it's nothing more than a map of vectors and maps.

The library called ~Oz~ allows us to define a Vega-Lite spec in Clojure, it compiles it to vega and renders it in a browser with minimal effort.
It even allows us to export the plot to a self-contained HTML using the javascript library ~vega-embed~.

Consider this neat code found in the repo's README:
#+BEGIN_SRC clojure
(ns org.core
  (:require [oz.core :as oz]))

(defn play-data [& names]
  (for [n names
        i (range 20)]
    {:time i :item n :quantity (+ (Math/pow (* i (count n)) 0.8) (rand-int (count n)))}))

(def line-plot
  {:data     {:values (play-data "monkey" "slipper" "broom")}
   :encoding {:x     {:field "time" :type "quantitative"}
              :y     {:field "quantity" :type "quantitative"}
              :color {:field "item" :type "nominal"}}
   :mark     "line"})

(oz/export! line-plot "public/html/line.html")
#+END_SRC

&nbsp; &nbsp;

Here 3 random time series are generated, encoded in the most obvious, concise, simple way and the result is what you would expect:
#+BEGIN_EXPORT html
<iframe src="../static/html/line.html" style="overflow:visible;min-height:300px;height:100%;width:100%;padding:20px" scrolling="no" border="none" width="100%" height="100%" marginheight="0" frameborder="0"></iframe>
#+END_EXPORT

What I love about this example is that you work with raw, naked data.
There is no class, no weird API syntax or function kwargs to memorize.

** Blog development:
Anoter interesting learning I had was how to embed Vega into this blog!
Because I don't know enough about web development, it took me way more than it should have.
Actually, it was really easy since you can just write plain HTML in markdown and that will be correctly parsed by ~markdown.core~ and ~reagent~.

When taking a compiled Vega spec, I can just put the SVG in a div tag.
When exporting it from Clojure, I can put the HTML file in an iframe.
It is just a bit annoying that this does not resize automatically but I can control it with the CSS attribute ~min-height~ and set it to the height I specify in Vega-lite.

Oz also has a facility to render a Reagent component directly from Clojure.
At the moment I am not using it as my blog posts are written in markdown/HTML, I could use it to populate another page of the website.

As a final cherry on top, writing my blog in Org mode has already shown its value.
Executing ~yarn develop~ starts the ~shadow-cljs~ server which will watch for changed files.
At the same time it will expose a Clojure REPL that I can connect to in order to execute my org src blocks.
When I am satisfied, I can just export to markdown and see the blog post reloading.
* Adding comments to the blog
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/blog-comments.md
:END:
title: Adding comments to the blog
subtitle: The simple, privacy-focused, not bloated way
date: 2020-06-07
id: blog-comments
tags: clojurescript react

** The requirements
I spent a day trying to integrate comments on this blog.
As always, things were simple but since I am a terrible web developer I spent a lot of time figuring out how to do it.
This gave me the opportunity to learn how to debug my clojurescript web app and to learn something about React so that is good!

I wanted to add comments at the end of my posts so I could gather feedback on what I write, to know whether I helped a random stranger or if something about my process could be improved.
My requirements for the commenting system I wanted to add were the following:
1. Free: I did not want to pay a monthly fee for my small blog with few monthly pageviews
2. Lightweight: my website's load speed should not suffer
3. No ads: my readers should have no waiting time to leave a quick comment
4. No login required: as above, I don't want to require my readers to have a Disqus or Github account
5. Simple, no backend installation: I wanted to keep my simple JAMstack setup with Netlify

It is not a small list when you look at it.
The thing is that I would not accept a solution which compromised on even one of the above points.

** Good solutions
The most popular solution for blogs is by far Disqus.
It is simple and free, however it is not lightweight and it has ads(!!).
They also have a bad reputation of not being privacy focused. Discarded.

One project I really liked was [[https://utteranc.es/][utterances]], which allows you to store the comments in a github repo.
It did not seem super trivial to integrate with my Reagent setup but it was a simple and elegant solution.
However, it compromised on requirement 4: you need a Github account to comment. I kept looking.

I found another interesting [[https://healeycodes.com/adding-comments-to-gatsby-with-netlify-and-github/][solution]] which made us of Netlify forms and functions.
When a commenter would post a comment, it would trigger a new website build.
Comments are filtered for spam by Netlify and are stored in a JSON file on Github.
However, again, it was not simple to integrate in my setup as the Netlify functions can only be written in Javascript.
I found a good [[https://github.com/healeycodes/gatsby-serverless-comments][reference]] to express functions in clojurescript and compile them and I was about to experiment to learn about serverless and lambda functions.
I liked the low-level idea of not relying on any service at all.
However, before diving into this project, I decided to try out a service which looked very simple AND respected all my requirements.

** The winner
I decided to try [[https://talk.hyvor.com/][Hyvor Talk]], they offer a similar service to Disqus but privacy-focused.
It does not look lightweight when you see a demo site but then you found out that you can load the component "on scroll" or by clicking a button. Nice!
They have a free tier, which seemed to be perfect for my use case.

The integration was quite simple: just add this piece of HTML to your blog posts and if they have a canonical URL everything will work out of the box.
Yeah, well, it is not easy with a single page application.
My blog posts are React components, where the HTML is set with the ~dangerouslySetInnerHTML~ function.
Fair enough, I said, I will write that piece of HTML in each of my post.
Then I found out that if the innerHTML contains a ~<script>~ tag, it will be skipped. Damn.

What I found out shortly after is that Hyvor Talk provides their own React component to embed the comments in your website!
After a bit of research I found out that ~shadow-cljs~ makes it extremely easy to install an existing React component and include it in your SPA!

Firs I installed the component with:
#+BEGIN_SRC sh
yarn add hyvor-talk-react
#+END_SRC

And this is my Reagent code:
#+BEGIN_SRC clojure
(ns app.core
  (:require ["hyvor-talk-react" :as HyvorTalk]))

(defn- comments [post-id]
  [:> HyvorTalk/Embed {:websiteId 123 :id post-id :loadMode "scroll"}])
#+END_SRC

The ~:>~ is special Reagent syntax that allows you to easily use javascript components.
Wow, the ~cljs~ + ~reagent~ + ~shadow-cljs~ combo really made this process so simple!
In the process I learned something abut the philosophy of React and I understand components a bit more.
* Literate learning
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/think-stats.md
:END:
title: Literate learning
subtitle: How to learn stats, clojure and vega-lite while having fun
date: 2020-06-17
id: think-stats
tags: clojure org vega-lite

** Think stats
When I first approached Clojure my curiosity brough me to look up what people were using to do Data Science in Clojure.
I found a book called [[https://www.packtpub.com/big-data-and-business-intelligence/clojure-data-science][Clojure for Data Science]], available through my employer's O'Reilly subscription.
I skimmed through it and saw it was introducing stats concepts in a very simple and clear way.
It was using the ~incanter~ "framework", which is unfortunately not in development anymore.

The author Henry Garner has also written [[http://clojuredatascience.com/posts/2016-12-02-data-science-ladder-abstraction.html][an interesting essay]] about his experience with Clojure.
He is also the author of a stats library called ~kixi.stats~.
In the essay he says that what he wrote this library while reading the book "Think stats".
He would re-implement the Python examples in Clojure.

The second edition of the book is [[https://greenteapress.com/wp/think-stats-2e/][available for free]] and so I went ahead and started reading it.
Even though I was familiar with most concepts, implementing them with simple functions and data structures deepened my understanding.

** Org code blocks
One of my favourite features of Emcas is ~org-mode~.
It is a markup language (arguably the best), which allows you to mix prose and code blocks.
A code block looks like this:
#+BEGIN_EXAMPLE
#+BEGIN_SRC clojure
(let [vec [1 2 3]]
  (reduce + vec))
#+END_SRC
#+END_EXAMPLE

It seems verbose to specify =#+BEGIN_SRC= and =#+END_SRC= everytime compared to, for example, markdown.
The process can be quickly automated and it is in fact a built-in feature:
just typing ~<s~ and pressing TAB will expand the source block and move the cursor for you so that you can type the language.
Another TAB will bring the cursor inside the block.

Syntax highlighting inside the block is easy to achieve.
The big wow moment is when you realize that you can /execute/ code blocks with a backend.
Cider kindly provides this backend.
When I execute my code block, CIDER will start a REPL.

Not only that, if I use =C-C '= to edit the code block, I get a temporary buffer where ~clojure-mode~ takes over:
#+BEGIN_EXPORT html
<img src="resources/org-edit.png" alt="Editing org source blocks" style="float: left; margin-right: 10px;" />
#+END_EXPORT

In this screenshot I am editing this blog post in org-mode.
I am editing the source block in the right-window.
When executing it, a ~shadow-cljs~ nREPL server was started and org-mode seamlessly connected to the session.
I can evaluate the ~let~ form with CIDER and print the result in the buffer.
All of the amazing CIDER features are available (refactor, debug).

Wait for the second wow moment.. you can execute different languages in the same document.
Org mode provides the means for sharing simple data structures between languages.
What is not supplied can be achieved easily by serializing intermediate results with one language and re-loading it in another language.
Data analysis in Python, visualization in R, no context switching.

You will need to give up Pycharm and Rstudio magics, though.
Some people might consider this is a good thing.
You need to understand what Pycharm handles behind the scenes and build it (better: compose it) yourself.
In 5 years maybe there will be another IDE leading the market.
I am pretty sure ~org-mode~ will still be there, along with the low-level concepts you learned in the effort.

An ~org-mode~ file is structured in sections, or headings.
Each of these headings can have subheadings.
They can be collapsed and expanded easily by Emacs.
This is very consistent with the structure of a book.

Notes are naturally organized in sections and subsections of the book.
The python code snippets of the book can be copied, pasted and executed.
Below I can open a clojure code snippet and rewrite it.

** Org inline plots
Another fantastic feature of ~org-mode~'s inline images.
In fact we can embed the result of a plot directly in the document.
Nowadays, with Jupyter Notebooks, this is expected and almost required.
Without much effort, I managed to embed .png files produced by ~vega-lite~.

For that I am using [[https://github.com/behrica/vg-cli][a thin clojure wrapper]] over ~vg-cli~.
This is an example of a source block which outputs graphics:
#+BEGIN_SRC clojure
(defn plot-spec [spec]
  (vg/vg-cli {:spec spec :format :png :output-filename "data/plots/tmp.png"}))

(let [ds   (ds/->dataset "data/thinkstats/nsfg.csv")
      spec {:data      {:values (-> (ds/filter #(== 1 (get % "outcome")) ds)
                                    (ds/select-columns ["prglngth"])
                                    (ds/mapseq-reader))}
            :mark      "bar"
            :encoding  {:x {:field "prglngth"
                            :type  "quantitative"}
                        :y {:aggregate "count"
                            :type      "quantitative"}}}]
  (plot-spec spec))
#+END_SRC

As described in my previous blog post, the specification is expressed in clojure and passed to the ~vg-cli~, which writes the .png to a path.

Note that the code block has certain ~header args~:
#+BEGIN_EXAMPLE
#+BEGIN_SRC clojure :results graphics file link :file ../../data/plots/tmp.png
...
#+END_SRC
#+END_EXAMPLE

They set the result to be a link to the path where the plot will be saved.

** Clojer to metal
Reading this book with this setup is a lot of fun.
I usually have the .pdf open on the right and Emacs on the left.
I can focus on one topic at a time, code in both languages, quickly see some plots.

The python code often uses ~pandas~, ~numpy~, ~matplotlib~.
I am replacing them with ~tech.ml.dataset~ + ~tablecloth~, ~fastmath~ and ~vega-lite~ respectively.

The ~dataset~ abstraction in the Clojure world is better than the pandas one.
I can express myself with maps and reduce on datasets or columns.
After a groupby, I can operate on each grouped dataset.
Which is nothing more than a sequence of maps.
No series, no index, no arcane syntax.

I could implement most functions like ~percentile~ or ~covariance~ on my own.
When things get more complicated, I am relying on ~fastmath~, which mostyly wraps ~org.apache.commons.math3~.
So far I used it for sampling from distributions and computing the kernel density estimate.

Speaking of visualizations, ~vega-lite~ has really been a pleasure to use.
Plots are supposed to be simple.
You either have a bar plot, a line plot or a scatter plot.
What is on the x axis and what is on the y axis?
We usually have a sequence of maps containing ~xs~, we can map functions over them to obtain ~ys~, plot them.

~vega-lite~ makes it also extremely easy to compose visualizations: auto-layer them, concatenate them vertically, horizontally.
This means that I can derive my building blocks as functions and very quickly compose them.
Again, not a slave of ~matplotlib~ APIs: subplots, xticks formatters and so on.
Visualizations as data.

Here is a snippet demonstrating ~tablecloth~ and ~vega-lite~ layers:
#+BEGIN_SRC clojure
(defn weight-vs-height-mapseq [ds rank]
  (-> (ds/select-columns ds ["htm3" "wtkg2"])
      (dss/drop-missing ["htm3"])
      (dss/select-rows (fn [row] (and (> (row "htm3") 135) (< (row "htm3") 200))))
      (dss/group-by (fn [row] (dfn/round (dfn// (row "htm3") 5))))
      (dss/aggregate {:mean-height       #(dfn/mean (% "htm3"))
                      :weight-percentile #(percentile ((dss/drop-missing % "wtkg2") "wtkg2") rank)} )
      (ds/mapseq-reader)))

(let [specs (for [[rank color] [[25 "blue"] [50 "green"] [75 "red"]]]
              (line-spec (weight-vs-height-mapseq brfss rank) :x-field :mean-height :y-field :weight-percentile :mark-color color))]
  (plot-spec  {:layer (into [] specs)}))
#+END_SRC

#+BEGIN_EXPORT html
<img src="resources/weight-vs-height.png" alt="Editing org source blocks" style="float: center" />
#+END_EXPORT

Apart from these super cool libraries, I am gaining confidence with the language.
I am solving problems faster, writing more idiomatic code (I like to refactor days-old code, extracting pure functions), getting comfortable with the tooling.
I like the idea that these pure functions are forever added to my toolbox, ready to be applied to other problems and domains.

** Conclusion
This post has briefly touched some topics and technologies that are really interesting to me such as data science, literate programming and clojure.
I barely scratched the topic of literature programming but I was glad to experiment with one of its use cases.
I will write another post in the future which showcases some other cool features such as weaving and tangling.
I hope that somebody can learn from the approach that I shared and maybe can suggest improvements to this workflow!
* React Native from Clojurescript
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/react-native-cljs.md
:END:
title: React Native from Clojurescript
subtitle: Develop native mobile apps in the most elegant way
date: 2020-09-20
id: react-native-cljs
tags: clojurescript reagent react-native

** React Native
I have always been curious about mobile apps development.
In 2018 I tried with a friend to launch a startup and the first thing I tried was to develop a mobile app.
I wanted to write my code only once for Android and iOS and not the same logic twice in Java+Swift.

At the time of research the two opponents were [[https://dotnet.microsoft.com/apps/xamarin][Xamarin]] and React Native.
The promise is the same: write the logic once, have the framework manage the native code.

After reading some pros and cons I decided to write ~C#~ with Xamarin because scared of React and Javascript and the fontend world.
It was an ok experience but the framework was not mature and ~C#~ did not excite me.
When I hit my first real problem when implementing authentication, I gave up.

Fast forward 2 years and React Native is mature and I am no longer afraid!
[[https://github.com/reagent-project/reagent][Reagent]] made me fall in love React and Clojurescript allows me to skip Javascript.

React Native with the support of Facebook has developed rapidly (most active github repo in 2019).
It can leverage the React ecosystem, it has good documentation, its generic components are well designed.

** Figwheel
Inspired by [[https://increasinglyfunctional.com/2020/05/07/clojurescript-react-native-krell-emacs.html][this blog post]], my first attemp at React Native from Clojurescript was with Krell.
Krell's philoshopy is to provide a very thin layer over React Native.
Well, I had some hiccups during the setup, I found it still (too) barebones.

Few months later I saw another announcement on Slack: ~figwheel~ for React Native.
I followed the [[https://figwheel.org/docs/react-native.html][Getting Started]] docs and I quickly had my iOS simulator running alongside ~figwheel~ hot-reloading.

I had also been hearing very good things about [[https://expo.io/][Expo]], which should handle for you complicated things like camera, location, notifications.
It was supported out of the box, here is my ~ios.cljs.edn~:
#+BEGIN_SRC clojure
^{:react-native :expo
  :launch-js ["yarn" "ios"]}
{:main app.core}
#+END_SRC
When I run ~cider-jack-in-cljs~, CIDER will ask me to run ~figwheel-main~, ~ios~ configuration.
This will return a ~cljs~ REPL and will run =yarn ios= in the background.
This is defined in =package.json= and runs ="expo start --ios"=.
With the iOS Simulator running I can then run the Expo app and select my iOS build.

** Reagent
My first steps consisted of learning what a React Native component is.
This is the first example in the Rect Native docs:
#+BEGIN_SRC js
import { Text, View } from 'react-native';

const YourApp = () => {
  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <Text>
        Hello World!
      </Text>
    </View>
  );
}
#+END_SRC
Javascript makes it slightly verbose but the concept is quite simple: our app includes a ~View~ component and inside that a ~Text~ component.
Since ~react-native~ is really just React, we can use ~reagent~ to have hiccup-like syntax and smart UI reloading.

Looking on github for repos using the ~cljs~ + ~react-native~ combo I realized that every developer uses ~js~ interop in a slightly different way to wrap ~react-native~ components.
The ~reagent-react-native~ project helps eliminating this "common boilerplate" by providing ready-to-use components.
This is my ~deps.edn~:
#+BEGIN_SRC clojure
{:deps {org.clojure/clojurescript     {:mvn/version "1.10.773"}
        io.vouch/reagent-react-native {:git/url "https://github.com/vouch-opensource/reagent-react-native.git"
                                       :sha     "54bf52788ab051920ed7641f386177374419e847"}
        reagent                       {:mvn/version "0.10.0"
                                       :exclusions  [cljsjs/react cljsjs/react-dom]}
        com.bhauman/figwheel-main     {:mvn/version "0.2.10-SNAPSHOT"}}}
#+END_SRC

And here is the minimal example above, with ~reagent~ syntax:
#+BEGIN_SRC clojure
(ns core.app
  (:require [react]
            [reagent.react-native :as rrn]))

(defn hello []
  [rrn/view {:style {:flex 1 :align-items "center" :justify-content "center"}}
   [rrn/text "Hello World!"]])
#+END_SRC
It can't get any more simple.
The reagent code is an abstraction for this lower level interop code:
#+BEGIN_SRC clojure
(def <> react/createElement)

(<> rn/View
      #js {:style #js {:flex            1
                       :align-items "center"
                       :justifyContent  "center"}}
      (<> rn/Text (str "HELLO WORLD!!")))
#+END_SRC

Following the React Native docs was relatively easy.
I only had troubles when wrapping the [[https://reactnative.dev/docs/using-a-listview][FlatList]] example:
#+BEGIN_SRC js
const FlatListBasics = () => {
  return (
    <View style={styles.container}>
      <FlatList
        data={[
          {key: 'Devin'},
          {key: 'Dan'},
        ]}
        renderItem={({item}) => <Text style={styles.item}>{item.key}</Text>}
      />
    </View>
  );
}
#+END_SRC

This is how I solved it:
#+BEGIN_SRC clojure
(defn flat-list []
  [rrn/flat-list
   {:data        [{:key "Devin"}
                  {:key "Devn"}]
    :render-item #(<> rn/Text
                      #js {:style #js {:color     "black" :textAlign "center"}}
                      (.-key (.-item %)))}])

#+END_SRC
The ~render-item~ function is passed a single argument, an object.
We can access the data accessing the ~.-item~ key.

** Calling clojure
You soon come to the realization that 99% of the mobile apps we use can be represented by React Native components, some simple data logic and styling.
What makes ~cljs~ attractive for mobile app development is that you can write your logic in ~clojure~.

To go beyond the basic tutorial, I decided to develop a quick app to play sudoku.
First I set up the View code to represent the Sudoku grid as a ~flat-list~, as explained above.
Then, to implement the Model code I resorted to Clojure, functional programming and lazy sequences.

Instead of having to spin up ~figwheel~ + ~Expo~ + Simulator, I could simply open a ~clj~ REPL.
After writing the code for my sudoku grid in ~sudoku.clj~ (note the ~defmacro~):
#+BEGIN_SRC clojure
(defmacro sudoku-grid []
  (->> (repeatedly nine-rows)
       (filter valid-rows?)
       (filter valid-columns?)
       (filter valid-blocks?)
       first))
#+END_SRC

I could simply "require it" in ~sudoku.cljs~:
#+BEGIN_SRC clojure
(ns app.sudoku
  (:require-macros [app.sudoku]))
#+END_SRC
I could have just written the logic directly in ~sudoku.cljs~ but this approach allows to leverage the whole ~clj~ ecosystem and permits faster experimentation.
This is the screenshot of the result, it was a lot of fun:
[[https://raw.githubusercontent.com/lccambiaghi/sudoku-cljsrn/master/assets/screen.png]]
* Doom gccemacs
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/doom-gccemacs.md
:END:
title: Doom gccemacs on MacOS\\
subtitle: The best IDE, now even faster\\
date: 2020-10-03\\
tags: emacs\\
id: doom-gccemacs

** Emacs is born
The first time I saw Emacs was on the ThinkPad of my Master Thesis' supervisor.
He was coding in R and he had split the screen in two parts, writing code to the left, evaluating it to see the results in the REPL on the right.
I was impressed by it, my setup at the time consisted of Jupyter Notebooks for exploration, Visual Studio to write LaTeX, Pycharm to debug and deploy batch jobs to the VM.

Little did I know that 2 years later I would have *integrated* my worfklow into one editor, the very same one he was using.
Another colleague of mine was using Emacs and when pair programming with him I was again struck by his workflow and some of the features of its editor.
One weekend, almost joking, I downloaded vanilla Emacs and I followed the tutorial.

Maaan, these weird keybindings.
Now I know that Emacs has been developed before the [[https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.f54dg00/cuahlp.htm][Common User Access]] guidelines were designed.
Its philoshopy allows the user to change keybindings to whatever you expect from it but it won't suggest it to you!

Of course I did not know how easy it would be to configure ~cua-mode~ in case I wanted standard =s-x=, =s-v= bindings to copy and paste.
However, on the same day I discovered that a popular alternative to the vanillla keybindings was the so-called ~evil-mode~.
The power of ~vim~'s modal editing and the expressivity of the ~lisp~ machine.

Very soon I learned about Emacs "distributions" or "starter kits".
The most popular is Spacemacs: it comes configured with all the "cool" packages, among them ~evil-mode~.
I then spent weeks learning about Spacemacs, Emacs and ~emacs-lisp~.

I will have to write another blog post to celebrate all my achievements with Emacs.
This one will just bedicated to the configuration of it.

** Doom
Some of Spacemacs qualities:
- Spacemacs is well documented and perfect for a first Emacs user.
- It is a community effort, things movest fast. Maybe too fast, looking at the number of open issues.
- It is feature complete. Maybe too complete, someone would argue it is slow.
- It abstracts away much of the complexity of Emacs. Maybe a bit too much, I would sometimes learn Spacemacs specific terminology but not so much ~elisp~.

Beacuse I am curios, I decided to try the second most popular Emacs distribution: [[https://github.com/hlissner/doom-emacs][Doom]] (I am still not amused by the name).
Here some of its qualities:
- Doom is not a comunity effort like Spacemacs but is mantained by one person, very active and helpful.
- There is a great community of users on [[https://discord.gg/qvGgnVx][Discord]], helpful and respectful.
- It is modular and completely configurable. The default configuration for the available modules is always well thought.
- It is carefully designed with performance in mind.
- It is much closer to the ~elisp~ metal. It offers cool macros to rebind keys, to install packages, etc.

Thanks to Doom I started to *configure* my editor and not just to rely on other people's modules.
I finally learned to inspect Emacs by describing functions and variables.
I learned about modes, hooks, advices.
I wrote some simple elisp functions to add features I needed.
[[https://lccambiaghi.github.io/.doom.d/readme.html][Here]] you can see an HTML render of my config.

** gccemacs
The Doom Emacs community is active on Discord, here is where I hear about the latest trends.
Lately (August 2020) the latest trend has definitely been [[https://www.emacswiki.org/emacs/GccEmacs][gccemacs]].
This is a development branch of Emacs HEAD which compiled elisp code to native code, bringing huge performance benefits.

Emacs is often accused of being slow compared to modern editors.
The dynamic nature of the ~elisp~ machine makes it by nature slower than the compiled counterparts.
This clever solution has gained popularity lately, so much that it has been announced it will be merged into master.

During these COVID times our team is working from home.
My work laptop is a dual core MacBook Pro, which has some performance issues when I am screen sharing and programming with Emacs.
One day I decided I had to try it. It was worth it.

I used [[https://github.com/jimeh/build-emacs-for-macos][this repo]] to build Emacs 28, ~feature/native-comp~ branch.
After cloning it, I first had to install a patched ~gcc~ version:
#+BEGIN_SRC sh
./install-patched-gcc
#+END_SRC
I had some installation issues which were solved by updating to the latest Apple's Command Line Tools.
You can do that with:
#+BEGIN_SRC sh
xcode-select --install
#+END_SRC

Once ~gcc~ was installed, I could build Emacs 28 with:
#+BEGIN_SRC sh
./build-emacs-for-macos --git-sha 3023eb569213a3dd5183640f6e322acd00ea536a feature/native-comp
#+END_SRC
You should pick a recent git sha by looking at [[https://github.com/jimeh/build-emacs-for-macos/issues/6][this issue]] which tracks "good commits" that lead to stable versions.

I then replaced my previous Emacs.app with the one just built.
Maybe that won't work for everybody, it depends how you installed Emacs27.
My previous installation was this tap of ~emacs-plus~:
#+BEGIN_SRC sh
brew tap d12frosted/emacs-plus
#+END_SRC
And this are the install options:
#+BEGIN_SRC sh
brew install emacs-plus --without-spacemacs-icon --HEAD --with-emacs-27-branch --with-jansson --with-modern-icon
#+END_SRC

** Gotchas
Doom Emacs already unofficially kind of supports ~gccemacs~.
I just replaced my Emacs.app with the new one and had to run:
#+BEGIN_SRC sh
doom sync && doom build
#+END_SRC
And wait for the compilation jobs to finish.

Once that was done I faced a few issues, which were not exactly well documented.
After running a second ~doom sync~ my Emacs failed to start with an error about some misteryous magit variable.
I found the solution on Discord: the guilty is a compiled autoloads file:
#+BEGIN_SRC sh
rm -rf ~/.emacs.d/local/cache/eln/x86_64-apple-darwin19.5.0-8b26f6d2e293e8b6/autoloads*.eln
#+END_SRC

Another important remark: Emacs 28 is unstable and some packages don't support it yet.
My workflow relies heavily on two packages: ~emacs-jupyter~ and ~dap-mode~.
Both of them were broken after the update.

When I tried to run ~emacs-jupyter~ in an ~.org~ file I was asked to download the ~zmq~ module, to which I agreed.
But then the installation broke because of a missing file.
I found the solution on a remote github issue: I had to change the extension of the downloaded ~.so~ file:
#+BEGIN_SRC sh
cd ~/.emacs.d/.local/straight/build/emacs-zmq
cp emacs-zmq.so emacs-zmq.dylib
#+END_SRC

To fix ~dap-mode~ I had to unpin few packages to enable the support of Emacs 28.
In fact, Doom locks pacakges to specific versions to make sure nothing breaks on the stable version (Emacs 27).
All I had to do was to write:
#+BEGIN_SRC emacs-lisp
(unpin! dap-mode lsp-mode treemacs)
#+END_SRC
In my ~.doom.d/packages.el~.

I hope some early adopter can find this blog post and solve some of his installation/configuration issues with these solutions!

* Restoring my Mac
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/restoring-my-mac.md
:END:
title: Restoring my Mac\\
subtitle: With an auto-configuring script\\
date: 2020-10-26\\
tags: mac emacs\\
id: restoring-my-mac

** setup.org
This week-end I restored my Mac.
I was having some major iCloud issues, my Documents and Desktop folders would not sync.
My Mac in general looked really tired.

I was prepared.
I took inspiration from a colleague's bash script to write my own configuration script, in ~org-mode~.
This format allows me to organize my ~sh~ code blocks within headlines and comments.
I can then ~tangle~ the blocks to a file ~setup.sh~, which I can run on the new Mac.

I can do this by having this property at the top of ~setup.org~:
#+begin_example
#+PROPERTY: header-args :tangle ~/git/org/personal/setup.sh
#+end_example

This is the structure of the document:
#+begin_example
 * macOs settings
 * brew
 * zsh
 * fonts
 * cli
 * gui
 * dotfiles
 * execute all
#+end_example

In each section I have a ~sh~ code block.
This is an example block from the "gui" section:
#+BEGIN_SRC sh
install_apps() {
    echo "Installing: base apps"
    BASE_APPS="google-chrome amethyst slack visual-studio-code firefox iterm2 iina menumeters 1password6 qbitorrent private-internet-access"
    brew tap homebrew/cask-versions
    brew cask install $BASE_APPS
    echo "Installing: docker"
    brew cask install docker
    echo "Installing: corporate"
    CORPORATE="microsoft-office keybase microsoft-azure-storage-explorer intune-company-portal microsoft-teams"
    brew cask install $CORPORATE
}
#+END_SRC

I can "export" the ~org~ file to ~setup.sh~ with ~M-x org-babel-tangle~.

** Recovery Mode and setup.sh
Before erasing all content gathered in 12 months, I quickly offloaded some files to a USB key.
I mostly cared about an "AI for trading" course and some work analyses not in version control.

Without thinking too much, I booted in Recovery Mode with cmd+R, erase the HD and reinstalled.
(I found out later that I forgot about my ~.gnupg~ folder with my private ~gpg~ key..)

While running my ~install.sh~ script, I realized my main needs:
- Emacs (+ Doom)
- Dropbox (org)
- Password Manager

I could survive with a browser and Emacs for a week.
Okay, maybe I would need Slack for work but not much else.

My first impulse was to rebuild ~gccemacs~ on my Mac, in parallel to my already big configuration efforts.
To my surprise, the process has been incredibly easy.
Well, maybe because I have already spent a few hours fighting ~gccemacs~ in the past weeks.

All I did to install it was to clone [[https://github.com/jimeh/build-emacs-for-macos][this]] repo and run:
1. ~brew bundle~
2. ~./build-emacs-for-macos --git-sha d5791ba5feeb5500433ca43506dda13c7c67ce14 feature/native-comp~
3. Move the app to ~Applications~.

In the meanwhile, my ~install.sh~ script was having some hiccups.
I got somehow 90% of the functionalities working (loads of ~brew~ downloads: CLI tools and GUI apps)
I had to manually copy-paste some commands from the harder sections such as ~install-zsh~ and ~restore-dotfiles~.
Overall, I am very satisfied: it really saved a lot of time.

Once I had built Emacs, I simply had to reinstall Doom.
On its first run with ~gccemacs~, Doom will now compile AOT all packages, which takes a while.

Halfway through, I cloned my Doom configuration (stored in git) to ~.doom.d~ and build the extra packages in my config.
With minimal effort, few minutes later, I had restored my feature-complete IDE.
~straight~ and ~Doom~ in general is amazing.

** Last manual steps
I then documented some final manual steps I had forgotten to include in my install script.
Some examples:
- Forgot to backup SSH keys... ~ssh-keygen~
- My [[https://rstudio.github.io/renv/articles/renv.html][renv]] library does not work. I had to add ~export R_LIBS_USER=...~ to my ~.zshenv~
- Forgot to install pyright.. ~brew install node && npm install -g pyright~
- iTerm2 does not send escape sequences.. follow [[https://www.clairecodes.com/blog/2018-10-15-making-the-alt-key-work-in-iterm2/][this]] guide.

It sounds like a waste of time and a lot of work to start from scratch and fight these issues.
I find it a valuable task that lets me learn about my workflow.
I document it and declare it.

I have achieved full reproducibility when it comes to my IDE.
Next step is my full computing environment.
That is why I am now looking at ~nix~ and ~home-manager~.
Expect a blog post about it in the near future!
* Nix: the functional package manager
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/nix-package-manager.md
:END:
title: Nix, the functional package manager\\
subtitle: Declare your software and dotfiles and make them reproducible forever\\
date: 2020-11-01\\
tags: nix home-manager\\
id: nix-package-manager

** Why should you care?
I recently had to restore my Mac, as I covered in my previous blog post.
I have now experienced what it is to start from scratch and have a software configure your new OS.

It was liberating to think that next time it would take me less than an hour to get up to speed.
This is called having a portable configuration.
Of course, the solution I described was not portable, actually limited to macOS.

I spent the past week or so learning about Nix.
Nix is a functional package manager that takes the concept of portable configuration to its furthest point.
In ~NixOS~ you can declare your whole system configuration, including hardware (eg. audio and display drivers).

It is the oldest story in the world, it is what the ~.emacs~ allows the Emacs user to do.
Declare the needed packages and how you want them configured, bring your configuration with you forever.
~nix~ extends this power to the entire computing environment.

My objective was to declare the fundamental building blocks of my workflow:
- ~CLI~ packages (~kubectl~, ~python~, ~poetry~, etc.)
- ~GUI~ apps (Dropbox, 1Password, Slack, etc.)
- ~zsh~ (~oh-my-zsh~, plugins, theme, etc.)
- ~emacs~ (~gccemacs~ and ~~/.doom.d/~)
- Dotfiles (e.g. ~~/.kube/config~, ~~/.ssh/id_rsa.pub~, ...)

** Installing Nix
If you are on ~macOS~, there are very high chances you are using ~brew~.
It is stable, user friendly, basically all packages are available.

Well, ~nix~ is far from that user experience.
I found its documentation quite difficult.
The installation process was hard.
There are not so many examples online you can learn from.

Let me now give you the good news.
As it is common with software that is difficult to tame..
it is totally worth it.

When you get a stable installation and you climb the first part of the steep learning curve..
it is impossible to come back.
Like Emacs.

So, with a good dose of patience follow my tutorial.

*** Create the ~nix~ volume
If you have the latest ~macOS~ Catalina, we will need to create a volume
where ~nix~ will download packages and build our environment.
A very cool feature is that we will be able to roll-back to previous "generations" of our environment.

We will issue a few commands at the terminal.
We are not doing anything dramatic and if something goes wrong we can easily delete the volume with Disk Utility and start the process from the beginning.
For reference, I followed [[https://www.philipp.haussleiter.de/2020/04/fixing-nix-setup-on-macos-catalina/][this]] and [[https://dubinets.io/installing-nix-on-macos-catalina/][this]] blog posts.

First we create the volume with the ~diskutil~ program:

#+BEGIN_SRC sh
sudo diskutil apfs addVolume disk1 APFS nix
#+END_SRC

Then we need to ask ~diskutil~ for the ~UUID~ of our volume:

#+BEGIN_SRC sh
diskutil info /dev/disk1s6 | grep UUID
#+END_SRC

Let's copy that information and paste it in the below command:

#+begin_src sh
echo "UUID=12345678-1234-1234-1234-123456789123 /nix apfs  rw" | sudo tee -a /etc/fstab
#+end_src

Finally, let's edit the ~/etc/synthetic.conf~ file:

#+BEGIN_SRC sh
echo 'nix' | sudo tee -a /etc/synthetic.conf
#+END_SRC

and restart.

*** Iinstall ~nix~
After the restart, we can set the volume as read-only:

#+BEGIN_SRC sh
sudo chown -R $(whoami) /nix
#+END_SRC

And install ~nix~:
z
#+BEGIN_SRC sh
sh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume --daemon
#+END_SRC

The installer is pretty straightforward.
To test that the installation went through, try a ~nix-shell~ command:

#+BEGIN_SRC sh
nix-shell -p ripgrep
#+END_SRC

If everything went well, congratulations!
Else, head over to the Troubleshooting section.

*** Install ~nix-darwin~
In order for ~nix~ to control some of the system services of ~macOS~, we need to install ~nix-darwin~.

#+BEGIN_SRC sh
nix-build https://github.com/LnL7/nix-darwin/archive/master.tar.gz -A installer
#+END_SRC

And execute the built installer:

#+BEGIN_SRC sh
./result/bin/darwin-installer
#+END_SRC

Finally, let's add the ~nixpkgs~ channel:

#+begin_src sh
sudo -i nix-channel --add https://nixos.org/channels/nixpkgs-20.09-darwin nixpkgs
sudo -i nix-channel --update nixpkgs
#+end_src

A channel is simply a repository where ~nix~ will look for downloads.
[[https://github.com/NixOS/nixpkgs][Here]] you can find the repository with the "recipe" for all the packages.
Once you gained confidence with the ~nix~ language, it is easy to write a recipe for a package and contribute it to the community.

*** Troubleshooting
Skip this section if you installed successfully.

In case the ~nix~ commands are not available to your path:
- First check that ~source ~/.nix-profile/etc/profile.d/nix.sh~ is in your ~~/.zshrc~ or ~~/.bashrc~
- Next, check that your ~.nix-profile~ is populated.

In my case, it was empty and I had to create the symlink myself with:

#+BEGIN_SRC sh
ln -s /nix/var/nix/profiles/default/bin .nix-profile
#+END_SRC

And then switching profile:

#+BEGIN_SRC sh
nix-env --switch-profile /nix/var/nix/profiles/per-user/$USER/profile
#+END_SRC

I faced another couple of misteryous errors when installing ~nix-darwin~, solved by exporting environment variables as indicated in some remote github issues.
Export them and run the commands again:

#+BEGIN_SRC sh
export NIX_SSL_CERT_FILE="/nix/var/nix/profiles/default/etc/ssl/certs/ca-bundle.crt"
export NIX_PATH=~/.nix-defexpr/channels:$NIX_PATH
#+END_SRC

** Home Manager
Alright, the complicated part is behind us.
We have just opened the door to new cool functional workflows.

The ~nix~ ecosystem is rich and complex.
I started with a package which aims to simplify "home" configuration.
It is called [[https://github.com/nix-community/home-manager][Home Manager]].

I recommend to start by cloning [[https://github.com/ryantm/home-manager-template][this repository]].
It contains a great template that you can start customizing right away.

The main thing to consider is the ~home.nix~ file:

#+BEGIN_SRC nix
{ pkgs, ... }:
{
  home.username = "$USER";
  home.homeDirectory = "$HOME";
  home.stateVersion = "20.09";
  #
  programs.bash = {
    enable = true;
  };
  home.packages = [
    pkgs.htop
    pkgs.fortune
  ];
}
#+END_SRC

Start by inserting your username and home directory.

Now you can run the helper commands available in the repo:
z
#+BEGIN_SRC sh
./update-dependencies.sh
./switch.sh
#+END_SRC

When the process completes, start a new shell.
If you didn't have it before, you have installed ~htop~ and can use it in your terminal.

It also installed another ~bash~ executable.
You can see all executables with ~which -a~:
z
#+BEGIN_SRC sh
~  which -a bash
/Users/luca/.nix-profile/bin/bash
/run/current-system/sw/bin/bash
/bin/bash
#+END_SRC

When you ran ~switch~, ~nix~ downloaded the declared packages and symlinked the executables in your ~~/.nix-profile~ folder.
~nix~ will simply add the packages to your ~PATH~ and it will not break your existing installation.

This is great because you can slowly migrate your ~brew~ packages.
And if something goes wrong, you can rollback to the previously built configuration with:

#+BEGIN_SRC sh
nix-env --rollback
#+END_SRC

In fact, I accepted that on ~macOS~ my ~home-manager~ configuration will live algonside a ~Brewfile~ to install ~GUI~ apps (~brew cask~ is much more stable and furnished).
Restoring my system will just amount to:

#+BEGIN_SRC sh
./update-dependencies.sh
./switch.sh
# install brew
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew bundle
#+END_SRC

and this is an extract of my ~Brewfile~:

#+BEGIN_SRC sh
# Taps
tap "homebrew/cask"
tap "homebrew/cask-versions"
tap "homebrew/core"
# Not available on nixpkgs
brew "azure-cli"
brew "parquet-tool"
brew "mas"
# GUI apps
cask "1password6"
cask "discord"
# ...
#+END_SRC

** Next steps
In this short post I tried to keep things simple.
There is a lot to explore in the ecosystem.

Some of the great tools to learn about:
- ~nix-shell~ allows you to spawn a shell with declared dependencies.
  Think one shell for building a LaTeX document.
  Another shell for a ~python~ project.
  You can avoid polluting your system and achieve stable, portable, sharable environments.
- The logical follower is ~nix-build~, which allows you to package your ~python~ project easily.
- We have seen ~nix-env~ in action with ~home-manager~.
  It is used for managing system configuration.

I will just end with a link to my personal ~nixpkgs~ repo which holds [[https://github.com/lccambiaghi/nixpkgs][my home configuration]].
* One year with Emacs
:PROPERTIES:
:EXPORT_FILE_NAME: ../src/posts/one-year-emacs.md
:END:
title: One year with Emacs\\
subtitle: Or, how I integrated my worfklows into one Environment\\
date: 2020-11-25\\
tags: emacs \\
id: emacs

outline?
- prelude:
  + interface between technologies: org
  + consistency: buffers, windows, REPL(clojure and jupyter), LSP
  + extensibility: LSP
- Spacemacs
- DOOM
- Emacs

workflows:
- pyright + dap-mode
- direnv
- nix
- magit
- org-mode
  + agenda
  + org-cv
  + inline latex
  + org-babel
- evil-mode
- vterm (eshell)

-> everything shell related is done in emacs
-> programming-specific IDEs are unified

** Prelude
In a couple previous blog posts I described a workflow enabled by Emacs.
The magic ~clojurescript~ does to compile to ~react-native~ is also enjoyable by developers who use Visual Studio Code.
The features I described of ~org-mode~ can be achieved by using ~jupyter notebook~ if you don't mind about working in the browser and versioning ~.json~ files.

The point of this blog post is not really about cool technologies like ~clojure~ or ~nix~.
The 99% of the people in the world who don't use Emacs will find a way to make use of them efficiently and with joy.

What I would like to describe are those workflows that are enabled by a smart interface between technologies.
I would like to emphasize the beauty of consistency.
But most importantly, the extensibility and how you can customize your development toolset to solve your personal problems.

** Spacemacs
Everything started on a random afternoon, browsing the web, downloading Emacs almost as a joke.
I follow its tutorial, I like the concept of moving across the screen with the keyboard.
I dislike everything else, most of all its odd look and arcane keybindings.

I was so close to trash it and move on.. but I kept on reading and found out about the popular Spacemacs.
The value proposition is clear:
- Make Emacs modern
- Gather all the cool packages and make them discoverable

I downloaded it and spent WEEKS reading its documentation around Christmas 2019.
Spacemacs comes with ~evil-mode~ (~vi~ keybindings) as default, so yep: learning Emacs and vim at the same time.
I was extremely slow, I could not do anything productive with it, it was basically like re-learning to type AND code from scratch.

I was hooked.
There was something misteryous about this software that kept me curious.

** DOOM
After a couple of months I moved to DOOM emacs.
The main reason was Spacemacs had become slow.
Often, I would not understand how things were working and very often I would not understand why things were not working.

DOOM has the same two goals as Spacemacs but it is much closer to the vanilla Emacs experience.
You are encouraged from day one to write a literate ~config.org~ file and there you go.
The first commit of my config is from 8th of February.

DOOM makes it very easy to inspect the source code of an ~elisp~ function.
You are encouraged to interrogate Emacs about what is happening: ~describe-variable~, ~describe-function~, ~describe-mode~, ~describe-key~.

I am still not proficient in ~elisp~, I mostly steal pieces from the internet.
I only wrote a couple of useful functions:
- An advice which would set the right ~python~ path according to the ~poetry~ virtual env
- A function which would start a ~ptvsd~ debugger in ~pytest~ on the test at point

Both functions have been adapted from existing functions which did similar things.
Both have been replaced by better tools (~direnv~ and ~dap-mode~) as of now.

** Emacs
- buffer: everything is text
- windows
- LISP (REPL)
- projectile

** Tools
- Magit
- org (babel)
- LSP
